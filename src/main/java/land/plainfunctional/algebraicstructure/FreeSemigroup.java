package land.plainfunctional.algebraicstructure;

import java.util.LinkedHashSet;
import java.util.SortedSet;
import java.util.function.BinaryOperator;

import land.plainfunctional.util.Arguments;

/**
 * {@inheritDoc}
 *
 * <p>...</p>
 *
 * <p>
 * A <i>free</i> semigroup, ùïÑ<sub>X</sub>, on a set X,
 * is the "most general possible" semigroup generated by X
 * (i.e., there are no relations or axioms imposed on the generators).
 * </p>
 *
 * <p>
 * When regarding <i>types as sets of values</i>,
 * one may treat types as (value) generators, predefined by the Java type system.<br>
 * So, a free semigroup, ùïÑ<sub><code>T</code></sub>, for the (parametric/generic) type <code>T</code>,
 * is expressed as <code>FreeSemigroup&lt;T&gt;</code>.
 * </p>
 *
 * <p>...</p>
 *
 * <p>
 * <i>Disclaimer:</i><br>
 * Finding myself kind of on a limb when it comes to the theoretical concepts and terms regarding this algebraic <i>free</i> thingy...<br>
 * I think the use of it here is mostly viable... hope so.
 * </p>
 *
 * @param <T> The semigroup type, all values of this type belongs to the semigroup
 * @see <a href="https://en.wikipedia.org/wiki/Free_monoid">Free semigroup (Wikipedia)</a>
 * @deprecated 'Free' mandates no (bounded) set of elements, does is not?
 */
@Deprecated // 'Free' mandates no (bounded) set of elements, does it not?
public class FreeSemigroup<T> extends Semigroup<T> {

    /**
     * @param linkedHashSet   set of elements which preserves its element insertion order when iterated
     * @param binaryOperation associative and closed binary operation
     */
    public FreeSemigroup(
        LinkedHashSet<T> linkedHashSet,
        BinaryOperator<T> binaryOperation
    ) {
        super(linkedHashSet, binaryOperation);
    }

    /**
     * @param sortedSet       set of elements which iteration order is defined by its 'Comparator' member
     * @param binaryOperation associative and closed binary operation
     */
    public FreeSemigroup(
        SortedSet<T> sortedSet,
        BinaryOperator<T> binaryOperation
    ) {
        super(sortedSet, binaryOperation);
    }

    /**
     * Application of this free semigroup's operation, an <i>endofunction</i> for <code>T</code>.
     *
     * <p>
     * <i>NB! The totality property of this free magma is enforced by the compiler's type system.</i>
     * </p>
     *
     * @param element1 a semigroup element
     * @param element2 a semigroup element
     * @return a resulting semigroup element, or a bottom value if the result is not an element of this magma
     * @throws IllegalArgumentException if the element values are equal
     */
    @Override
    public T append(T element1, T element2) {
        Arguments.requireNotNull(element1, "'element1' argument cannot be 'null'");
        Arguments.requireNotNull(element2, "'element2' argument cannot be 'null'");

        if (element1.equals(element2)) {
            throw new IllegalArgumentException("Cannot append two equal element values in a magma");
        }

        return this.binaryOperation.apply(element1, element2);
    }

    /*
     * By providing a identity element, this semigroup can be promoted to a {@link FreeMonoid} instance.
     *
     * @param identityElement the monoid's identity element
     * @return a new 'FreeMonoid' instance
     /
    public FreeMonoid<T> toFreeMonoid(T identityElement) {
        return new FreeMonoid<>((SortedSet<T>) this.set, this.binaryOperation, identityElement);
    }
    */
}
