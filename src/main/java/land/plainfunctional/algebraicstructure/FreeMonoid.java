package land.plainfunctional.algebraicstructure;

import java.util.LinkedHashSet;
import java.util.Set;
import java.util.SortedSet;
import java.util.function.BinaryOperator;
import java.util.function.Supplier;

import land.plainfunctional.monad.Promise;
import land.plainfunctional.monad.Reader;
import land.plainfunctional.util.Arguments;

/**
 * A <b>monoid</b> is a <i>semigroup with an identity element</i>.
 *
 * <p>
 * <i>Formally:</i> A monoid is a set 𝕊 with a closed, and associative binary operation, •,
 * which has an <i>identity element</i> <i>e</i> defined as:<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∃(<i>e</i>) ∈ 𝕊 ⇒ ∀(𝓍) ∈ 𝕊 ⇒ <i>e</i> • x = x • <i>e</i> = x
 * </p>
 *
 * <p>
 * There exists an element <i>e</i> in 𝕊 such that for every element 𝓍 in 𝕊,
 * the equation <i>e</i> • x = x • <i>e</i> = x holds.
 * The element <i>e</i> is called an identity element.
 * </p>
 *
 * <p>
 * The identity element/identity value is also called "the neutral element".
 * </p>
 *
 * <p>
 * With the identity element and the associative operation, we have all we need for "collapsing the monoid";
 * Reducing all the elements into one single element&mdash;<i>folding</i>.
 * </p>
 *
 * <p>...</p>
 *
 * <p>
 * A <i>free</i> monoid, 𝕄<sub>X</sub>, on a set X,
 * is the "most general possible" monoid generated by X
 * (i.e., there are no relations or axioms imposed on the generators).
 * </p>
 *
 * <p>
 * When regarding <i>types as sets of values</i>,
 * one may treat types as (value) generators, predefined by the Java type system.<br>
 * So, a free monoid, 𝕄<sub><code>T</code></sub>, for the (parametric/generic) type <code>T</code>,
 * is expressed as <code>FreeMonoid&lt;T&gt;</code>.
 * </p>
 *
 * <p>...</p>
 *
 * <p>
 * <i>Disclaimer:</i><br>
 * Finding myself kind of on a limb when it comes to the theoretical concepts and terms regarding this algebraic <i>free</i> thingy...<br>
 * I think the use of it here is mostly correct... hope so.
 * </p>
 *
 * @param <T> The monoid type, all values of this type belongs to the monoid
 * @see <a href="https://en.wikipedia.org/wiki/Monoid">Monoid (Wikipedia)</a>
 * @see <a href="https://en.wikipedia.org/wiki/Identity_element">Identity element (Wikipedia)</a>
 * @see <a href="https://en.wikipedia.org/wiki/Free_monoid">Free monoid (Wikipedia)</a>
 */
public class FreeMonoid<T> extends FreeSemigroup<T> {

    /**
     * This monoid's identity element/value.
     */
    public final T identityElement;

    /**
     * @param binaryOperation associative and closed binary operation
     * @param identityElement identity element
     */
    public FreeMonoid(
        BinaryOperator<T> binaryOperation,
        T identityElement
    ) {
        super(binaryOperation);
        Arguments.requireNotNull(identityElement, "A monoid must have an identity element - a neutral element");
        this.identityElement = identityElement;
    }

    /**
     * @return a deferred ("nullary"/constant function/Reader) version of this monoid's identity element
     */
    public Supplier<T> deferredIdentity() {
        return
            () ->
                this.identityElement;
    }

    /**
     * To <i>fold</i> a value (e.g. a monoid) means creating a new representation of it.
     *
     * <p>
     * In abstract algebra, this is known as a <i>catamorphism</i>.
     * A catamorphism deconstructs (destroys) structures
     * in contrast to the <i>homomorphic</i> <i>preservation</i> of structures,
     * and <i>isomorphisms</i> where one can <i>resurrect</i> the originating structure.
     * </p>
     *
     * Using Haskell-style function signatures, fold is defined as:
     * <p>
     * <code>
     * &nbsp;&nbsp;&nbsp;&nbsp;(a -&gt; a -&gt; a) -&gt; a -&gt; s a -&gt; a
     * </code>
     * </p>
     *
     * <p>
     * <i>This means</i>: A binary function <code>a -&gt; a -&gt; a</code>,
     * together with an initial value, also of type <code>a</code>,
     * is applied to a monoidal structure <code>s</code> of type <code>a</code>,
     * returning a new value of type <code>a</code>.
     * </p>
     *
     * <p>...</p>
     *
     * <p>
     * For the time being, this fold implementation is a "left fold"/"fold-left",
     * starting with the identity value, and appending/adding the left-most (first) element,
     * defined by this monoid's sorted set order -
     * and then appending/adding the rest of the elements "going to the right".
     * Do notice that the first 'append' parameter acts as the accumulated value while folding.
     * </p>
     *
     * @param enumeratedSet set of enumerated elements
     * @return the folded value
     */
    public T fold(Set<T> enumeratedSet) {
        return toMonoidStructure(enumeratedSet).fold();
    }

    /**
     * By providing an enumerated set (ensuring the binary operation's associativity requirement),
     * this free monoid can be promoted to a free monoid (only limited by the data type),
     * plus bounded subset of the data type as the monoid set.
     *
     * @param enumeratedSet set of enumerated elements
     * @return a free monoid including a bounded subset of the data type as the monoid set
     * @throws IllegalArgumentException if the given 'enumeratedSet' parameter is not a {@link LinkedHashSet} or {@link SortedSet} instance
     */
    public MonoidStructure<T> toMonoidStructure(Set<T> enumeratedSet) {
        if (this instanceof MonoidStructure<?>) {
            return (MonoidStructure<T>) this;
        }
        if (enumeratedSet instanceof LinkedHashSet<?>) {
            return new MonoidStructure<>((LinkedHashSet<T>) enumeratedSet, this.binaryOperation, this.identityElement);
        }
        if (enumeratedSet instanceof SortedSet<?>) {
            return new MonoidStructure<>((SortedSet<T>) enumeratedSet, this.binaryOperation, this.identityElement);
        }
        throw new IllegalArgumentException("The given 'enumeratedSet' argument must be strictly enumerated");
    }

    /**
     * @return a (deferred) 'Reader' version of this monoid's identity element
     */
    public Reader<T> toReaderIdentity() {
        return Reader.startingWith(this.identityElement);
    }

    /**
     * @return a (deferred, and not resolved) 'Promise' version of this monoid's identity element
     */
    public Promise<T> toPromiseIdentity() {
        //return Promise.startingWith(this.identityElement);
        return Promise.of(deferredIdentity());
    }
}
