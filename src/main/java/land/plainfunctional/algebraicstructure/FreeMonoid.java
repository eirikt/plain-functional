package land.plainfunctional.algebraicstructure;

import java.util.LinkedHashSet;
import java.util.Set;
import java.util.SortedSet;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;

import land.plainfunctional.util.Arguments;

/**
 * A <b>monoid</b> is a <i>semigroup with an identity element</i>.
 *
 * <p>
 * <i>Formally:</i> A monoid is a set ùïä with a closed, and associative binary operation, ‚Ä¢,
 * which has an <i>identity element</i> <i>e</i> defined as:<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚àÉ(<i>e</i>) ‚àà ùïä ‚áí ‚àÄ(ùìç) ‚àà ùïä ‚áí <i>e</i> ‚Ä¢ x = x ‚Ä¢ <i>e</i> = x
 * </p>
 *
 * <p>
 * There exists an element <i>e</i> in ùïä such that for every element ùìç in ùïä,
 * the equation <i>e</i> ‚Ä¢ x = x ‚Ä¢ <i>e</i> = x holds.
 * The element <i>e</i> is called an identity element.
 * </p>
 *
 * <p>
 * The identity element/identity value is also called "the neutral element".
 * </p>
 *
 * <p>
 * With the identity element and the associative operation, we have all we need for "collapsing the monoid";
 * Reducing all the elements into one single element&mdash;<i>folding</i>.
 * </p>
 *
 * <p>...</p>
 *
 * <p>
 * A <i>free</i> monoid, ùïÑ<sub>X</sub>, on a set X,
 * is the "most general possible" monoid generated by X
 * (i.e., there are no relations or axioms imposed on the generators).
 * </p>
 *
 * <p>
 * When regarding <i>types as sets of values</i>,
 * one may treat types as (value) generators, predefined by the Java type system.<br>
 * So, a free monoid, ùïÑ<sub><code>T</code></sub>, for the (parametric/generic) type <code>T</code>,
 * is expressed as <code>FreeMonoid&lt;T&gt;</code>.
 * </p>
 *
 * <p>...</p>
 *
 * <p>
 * <i>Disclaimer:</i><br>
 * Finding myself kind of on a limb when it comes to the theoretical concepts and terms regarding this algebraic <i>free</i> thingy...<br>
 * I think the use of it here is mostly viable... hope so.
 * </p>
 *
 * @param <T> The monoid type, all values of this type belongs to the monoid
 * @see <a href="https://en.wikipedia.org/wiki/Monoid">Monoid (Wikipedia)</a>
 * @see <a href="https://en.wikipedia.org/wiki/Identity_element">Identity element (Wikipedia)</a>
 * @see <a href="https://en.wikipedia.org/wiki/Free_monoid">Free monoid (Wikipedia)</a>
 */
public class FreeMonoid<T> {

    /**
     * This monoids's binary operation.
     *
     * <p>
     * The totality/closure property which the binary operation also must inhibit,
     * is enforced via the single-parametric {@link BinaryOperator} class,
     * in addition to constraints defined in the <code>append</code> method.
     * </p>
     */
    public final BinaryOperator<T> binaryOperation;

    /**
     * This monoid's identity element.
     */
    public final T identityElement;

    /**
     * @param binaryOperation associative and closed binary operation
     * @param identityElement identity element
     */
    public FreeMonoid(
        BinaryOperator<T> binaryOperation,
        T identityElement
    ) {
        Arguments.requireNotNull(binaryOperation, "A monoid must have a binary operation");
        Arguments.requireNotNull(identityElement, "A monoid must have an identity element - a neutral element");
        this.binaryOperation = binaryOperation;
        this.identityElement = identityElement;
    }

    /**
     * @return a deferred ("nullary"/constant function) version of this monoid's identity elements
     */
    public Supplier<T> deferredIdentity() {
        return
            () ->
                this.identityElement;
    }

    /**
     * @return a curried version of this monoid's associative, closed, binary operation
     */
    public Function<T, Function<T, T>> curriedBinaryOperation() {
        return
            (arg1) ->
                (arg2) ->
                    this.binaryOperation.apply(arg1, arg2);
    }

    /**
     * Application of this monoid's operation, ‚Ä¢<br>
     * This is an <i>endofunction</i>/<i>endomorphism</i>.
     *
     * <p>
     * <i>
     * NB! Partial method:<br>
     * The parameter values as well as the result must be actual elements of this magma.
     * </i><br>
     * Violations of this rule will result in a <i>bottom</i> value&mdash;here <code>null</code> or runtime exceptions.
     * </p>
     *
     * @param element1 a monoid element
     * @param element2 a monoid element
     * @return a resulting magma element, or a bottom value if one of the arguments or the result is not an element of this monoid
     * @throws IllegalArgumentException if one or both of the arguments are not elements of this monoid
     */
    public T append(T element1, T element2) {
        Arguments.requireNotNull(element1, "'element1' argument cannot be 'null'");
        Arguments.requireNotNull(element2, "'element2' argument cannot be 'null'");

        // No, makes 'append' not applicable when used for e.g. folding
        //if (element1.equals(element2)) {
        //    // Monoid exception for folding with the identity element as the initial value
        //    if (!element1.equals(this.identityElement)) {
        //        throw new IllegalArgumentException("Cannot append two equal element values in a monoid");
        //    }
        //}

        return this.binaryOperation.apply(element1, element2);
    }

    /**
     * <p>
     * To <i>fold</i> a value (e.g. a monoid) means creating a new representation of it.
     * </p>
     *
     * <p>
     * In abstract algebra, this is known as a <i>catamorphism</i>.
     * A catamorphism deconstructs (destroys) structures
     * in contrast to the <i>homomorphic</i> <i>preservation</i> of structures,
     * and <i>isomorphisms</i> where one can <i>resurrect</i> the originating structure.
     * </p>
     *
     * Using Haskell-style function signatures, fold is defined as:
     * <p>
     * <code>
     * &nbsp;&nbsp;&nbsp;&nbsp;(a -&gt; a -&gt; a) -&gt; a -&gt; s a -&gt; a
     * </code>
     * </p>
     *
     * <p>
     * <i>This means</i>: A binary function <code>a -&gt; a -&gt; a</code>,
     * together with an initial value, also of type <code>a</code>,
     * is applied to a monoidal structure <code>s</code> of type <code>a</code>,
     * returning a new value of type <code>a</code>.
     * </p>
     *
     * <p>...</p>
     *
     * <p>
     * For the time being, this fold implementation is a "left fold"/"fold-left",
     * starting with the identity value, and appending/adding the left-most (first) element,
     * defined by this monoid's sorted set order -
     * and then appending/adding the rest of the elements "going to the right".
     * Do notice that the first 'append' parameter acts as the accumulated value while folding.
     * </p>
     *
     * @param enumeratedSet set of enumerated elements
     * @return the folded value
     */
    //public T fold(SortedSet<T> set) {
    //    T foldedValue = this.identityElement;
    //    for (T value : set) {
    //        foldedValue = append(foldedValue, value);
    //    }
    //    return foldedValue;
    //}
    //public T fold(LinkedHashSet<T> set) {
    //    T foldedValue = this.identityElement;
    //    for (T value : set) {
    //        foldedValue = append(foldedValue, value);
    //    }
    //    return foldedValue;
    //}
    //public T fold(Set<T> set) {
    //    if (!(set instanceof SortedSet || set instanceof LinkedHashSet)) {
    //        throw new IllegalArgumentException("The set argument must be strictly enumerated");
    //    }
    //    T foldedValue = this.identityElement;
    //    for (T value : set) {
    //        foldedValue = append(foldedValue, value);
    //    }
    //    return foldedValue;
    //}
    public T fold(Set<T> enumeratedSet) {
        return toMonoidStructure(enumeratedSet).fold();
    }

    /**
     * By providing an enumerated set (ensuring the binary operation's associativity requirement),
     * this free monoid can be promoted to a free monoid (only limited by the data type),
     * plus bounded subset of the data type as the monoid set.
     *
     * @param enumeratedSet set of enumerated elements
     * @return a free monoid including a bounded subset of the data type as the monoid set
     * @throws IllegalArgumentException if the given 'enumeratedSet' parameter is not a {@link LinkedHashSet} or {@link SortedSet} instance
     */
    public MonoidStructure<T> toMonoidStructure(Set<T> enumeratedSet) {
        if (this instanceof MonoidStructure<?>) {
            return (MonoidStructure<T>) this;
        }
        if (enumeratedSet instanceof LinkedHashSet) {
            return new MonoidStructure<>((LinkedHashSet<T>) enumeratedSet, this.binaryOperation, this.identityElement);
        }
        if (enumeratedSet instanceof SortedSet) {
            return new MonoidStructure<>((SortedSet<T>) enumeratedSet, this.binaryOperation, this.identityElement);
        }
        throw new IllegalArgumentException("The given 'enumeratedSet' argument must be strictly enumerated");
    }
}
