package land.plainfunctional.algebraicstructure;

import java.util.LinkedHashSet;
import java.util.SortedSet;
import java.util.function.BinaryOperator;

import land.plainfunctional.util.Arguments;

/**
 * {@inheritDoc}
 *
 * <p>...</p>
 *
 * <p>
 * A <i>free</i> monoid, ùïÑ<sub>X</sub>, on a set X,
 * is the "most general possible" monoid generated by X
 * (i.e., there are no relations or axioms imposed on the generators).
 * </p>
 *
 * <p>
 * When regarding <i>types as sets of values</i>,
 * one may treat types as (value) generators, predefined by the Java type system.<br>
 * So, a free monoid, ùïÑ<sub><code>T</code></sub>, for the (parametric/generic) type <code>T</code>,
 * is expressed as <code>FreeMonoid&lt;T&gt;</code>.
 * </p>
 *
 * <p>...</p>
 *
 * <p>
 * <i>Disclaimer:</i><br>
 * Finding myself kind of on a limb when it comes to the theoretical concepts and terms regarding this algebraic <i>free</i> thingy...<br>
 * I think the use of it here is mostly viable... hope so.
 * </p>
 *
 * @param <T> The monoid type, all values of this type belongs to the monoid
 * @see <a href="https://en.wikipedia.org/wiki/Free_monoid">Free monoid (Wikipedia)</a>
 */
public class FreeMonoid<T> extends Monoid<T> {

    /**
     * @param linkedHashSet   set of elements which preserves its element insertion order when iterated
     * @param binaryOperation associative and closed binary operation
     * @param identityElement identity element
     */
    public FreeMonoid(
        LinkedHashSet<T> linkedHashSet,
        BinaryOperator<T> binaryOperation,
        T identityElement
    ) {
        super(linkedHashSet, binaryOperation, identityElement);
    }

    /**
     * @param sortedSet       set of elements which iteration order is defined by its 'Comparator' member
     * @param binaryOperation associative and closed binary operation
     * @param identityElement identity element
     */
    public FreeMonoid(
        SortedSet<T> sortedSet,
        BinaryOperator<T> binaryOperation,
        T identityElement
    ) {
        super(sortedSet, binaryOperation, identityElement);
    }

    /**
     * Application of this monoid's operation ‚Ä¢<br>
     * This is an <i>endofunction</i>/<i>endomorphism</i>.
     *
     * <p>
     * <i>
     * NB! Partial method:<br>
     * The parameter values as well as the result must be actual elements of this magma.
     * </i><br>
     * Violations of this rule will result in a <i>bottom</i> value&mdash;here runtime exceptions.
     * </p>
     *
     * @param element1 a monoid element
     * @param element2 a monoid element
     * @return a resulting magma element, or a bottom value if the result is not an element of this monoid
     * @throws IllegalArgumentException if one or both of the arguments are not elements of this monoid
     * @throws IllegalStateException    if the result of the applied operation is not element of this monoid
     */
    @Override
    public T append(T element1, T element2) {
        Arguments.requireNotNull(element1, "'element1' argument cannot be 'null'");
        Arguments.requireNotNull(element2, "'element2' argument cannot be 'null'");

        // No, makes 'append' not applicable when used for e.g. folding
        //if (element1.equals(element2)) {
        //    // Monoid exception for folding with the identity element as the initial value
        //    if (!element1.equals(this.identityElement)) {
        //        throw new IllegalArgumentException("Cannot append two equal element values in a monoid");
        //    }
        //}

        return this.binaryOperation.apply(element1, element2);
    }

    /**
     * <p>
     * To <i>fold</i> a value (e.g. a monoid) means creating a new representation of it.
     * </p>
     *
     * <p>
     * In abstract algebra, this is known as a <i>catamorphism</i>.
     * A catamorphism deconstructs (destroys) structures
     * in contrast to the <i>homomorphic</i> <i>preservation</i> of structures,
     * and <i>isomorphisms</i> where one can <i>resurrect</i> the originating structure.
     * </p>
     *
     * Using Haskell-style function signatures, fold is defined as:
     * <p>
     * <code>
     * &nbsp;&nbsp;&nbsp;&nbsp;(a -&gt; a -&gt; a) -&gt; a -&gt; s a -&gt; a
     * </code>
     * </p>
     *
     * <p>
     * <i>This means</i>: A binary function <code>a -&gt; a -&gt; a</code>,
     * together with an initial value, also of type <code>a</code>,
     * is applied to a monoidal structure <code>s</code> of type <code>a</code>,
     * returning a new value of type <code>a</code>.
     * </p>
     *
     * <p>...</p>
     *
     * <p>
     * For the time being, this fold implementation is a "left fold"/"fold-left",
     * starting with the identity value, and appending/adding the left-most (first) element,
     * defined by this monoid's sorted set order -
     * and then appending/adding the rest of the elements "going to the right".
     * </p>
     *
     * @return the folded value
     */
    public T fold() {
        T foldedValue = this.identityElement;
        for (T value : this.set) {
            foldedValue = append(foldedValue, value);
        }
        return foldedValue;
    }
}
